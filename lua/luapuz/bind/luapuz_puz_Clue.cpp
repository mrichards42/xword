// ---------------------------------------------------------------------------
// luapuz_puz_Clue.cpp was generated by puzbind.lua
//
// Any changes made to this file will be lost when the file is regenerated.
// ---------------------------------------------------------------------------

extern "C" {
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
}

#include "../luapuz_functions.hpp"
#include "../luapuz_tracking.hpp"

#include "luapuz_puz_Clue.hpp"
#include "luapuz_puz.hpp"
// ---------------------------------------------------------------------------
// class Clue
// ---------------------------------------------------------------------------



const char * Clue_meta = "puz.Clue";

// Create a new userdata with actual data and push it on the stack.
// The userdata will be tracked in the tracked objects table.
LUAPUZ_API void luapuz_newClue(lua_State * L,
                               puz::Clue * clue,
                               bool should_gc)
{
    // Create the userdata
    Clue_ud * ud =
        (Clue_ud *)lua_newuserdata(L, sizeof(Clue_ud));

    ud->should_gc = should_gc;

    // Set the data member
    ud->clue = clue;

    // Set the metatable
    luaL_getmetatable(L, Clue_meta);
    lua_setmetatable(L, -2);

    // Track the object
    luapuz_track_object(L, clue);
}



// Delete the data on garbage collection
int Clue_gc(lua_State * L)
{
#ifdef LUAPUZ_DEBUG
    std::cout << "Garbage collecting puz::Clue ";
#endif
    Clue_ud * ud = luapuz_checkClue_ud(L, 1);
    luapuz_untrack_object(L, ud->clue);
    if (ud->should_gc)
    {
        // If the user calls Clue:__gc() before this object
        // is garbage collected, we might try to delete ud->clue twice.
        ud->should_gc = false;
        delete ud->clue;
#ifdef LUAPUZ_DEBUG
        std::cout << "and deleting data" << std::endl;
#endif
    }
    else
    {
#ifdef LUAPUZ_DEBUG
        //std::cout << "but not deleting data" << std::endl;
#endif
    }
    return 0;
}

// tostring() -> userdata 0xHHHHH (puz.Clue 0xHHHH)
int Clue_tostring(lua_State * L)
{
    Clue_ud * ud = luapuz_checkClue_ud(L, 1);
    lua_pushfstring(L, "userdata: %p (%s: %p gc = %s)", ud, Clue_meta, ud->clue, ud->should_gc ? "true" : "false");
    return 1;
}

// Clue functions
//----------------
// int GetInt()
static int Clue_GetInt(lua_State * L)
{
    puz::Clue * clue = luapuz_checkClue(L, 1);
    int returns = clue->GetInt();
    lua_pushnumber(L, returns);
    return 1;
}
// puz::string_t GetNumber()
static int Clue_GetNumber(lua_State * L)
{
    puz::Clue * clue = luapuz_checkClue(L, 1);
    puz::string_t returns = clue->GetNumber();
    luapuz_pushstring_t(L, returns);
    return 1;
}
// void SetNumber(puz::string_t number)
static int Clue_SetNumber(lua_State * L)
{
    puz::Clue * clue = luapuz_checkClue(L, 1);
    puz::string_t number = luapuz_checkstring_t(L, 2);
    clue->SetNumber(number);
    return 0;
}
// puz::string_t GetText()
static int Clue_GetText(lua_State * L)
{
    puz::Clue * clue = luapuz_checkClue(L, 1);
    puz::string_t returns = clue->GetText();
    luapuz_pushstring_t(L, returns);
    return 1;
}
// void SetText(puz::string_t text)
static int Clue_SetText(lua_State * L)
{
    puz::Clue * clue = luapuz_checkClue(L, 1);
    puz::string_t text = luapuz_checkstring_t(L, 2);
    clue->SetText(text);
    return 0;
}
// Word GetWord()
static int Clue_GetWord(lua_State * L)
{
    puz::Clue * clue = luapuz_checkClue(L, 1);
    puz::Word * returns = &clue->GetWord();
    luapuz_pushWord(L, returns);
    return 1;
}
static const luaL_reg Cluelib[] = {
    {"GetInt", Clue_GetInt},
    {"GetNumber", Clue_GetNumber},
    {"SetNumber", Clue_SetNumber},
    {"GetText", Clue_GetText},
    {"SetText", Clue_SetText},
    {"GetWord", Clue_GetWord},
    {NULL, NULL}
};

const luaL_reg classCluelib[] = {
    { "__gc",        Clue_gc },
    { "__index",     luapuz_index },
    { "__newindex",  luapuz_newindex },
    { "__tostring",  Clue_tostring },
    { NULL, NULL }
};

void luapuz_openCluelib (lua_State *L) {
    // The Clue table, and the metatable for Clue objects
    luaL_newmetatable(L, Clue_meta);

    // register metatable functions
    luaL_register(L, NULL, Cluelib);
    luaL_register(L, NULL, classCluelib);

    // puz.Clue = the table
    lua_setfield(L, -2, "Clue");
}
