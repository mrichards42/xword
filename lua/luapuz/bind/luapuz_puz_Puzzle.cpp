// ---------------------------------------------------------------------------
// luapuz_puz_Puzzle.cpp was generated by puzbind.lua
//
// Any changes made to this file will be lost when the file is regenerated.
// ---------------------------------------------------------------------------

extern "C" {
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
}

#include "../luapuz_functions.hpp"
#include "../luapuz_tracking.hpp"

#include "luapuz_puz_Grid.hpp"
#include "luapuz_puz_Puzzle_helpers.hpp"
#include "luapuz_puz.hpp"
#include "luapuz_puz_Puzzle.hpp"
// ---------------------------------------------------------------------------
// class Puzzle
// ---------------------------------------------------------------------------



const char * Puzzle_meta = "puz.Puzzle";

// Create a new userdata with actual data and push it on the stack.
// The userdata will be tracked in the tracked objects table.
LUAPUZ_API void luapuz_newPuzzle(lua_State * L,
                               puz::Puzzle * puzzle,
                               bool should_gc)
{
    // Create the userdata
    Puzzle_ud * ud =
        (Puzzle_ud *)lua_newuserdata(L, sizeof(Puzzle_ud));

    ud->should_gc = should_gc;

    // Set the data member
    ud->puzzle = puzzle;

    // Set the metatable
    luaL_getmetatable(L, Puzzle_meta);
    lua_setmetatable(L, -2);

    // Track the object
    luapuz_track_object(L, puzzle);
}



// Delete the data on garbage collection
int Puzzle_gc(lua_State * L)
{
#ifdef LUAPUZ_DEBUG
    std::cout << "Garbage collecting puz::Puzzle ";
#endif
    Puzzle_ud * ud = luapuz_checkPuzzle_ud(L, 1);
    luapuz_untrack_object(L, ud->puzzle);
    if (ud->should_gc)
    {
        // If the user calls Puzzle:__gc() before this object
        // is garbage collected, we might try to delete ud->puzzle twice.
        ud->should_gc = false;
        delete ud->puzzle;
#ifdef LUAPUZ_DEBUG
        std::cout << "and deleting data" << std::endl;
#endif
    }
    else
    {
#ifdef LUAPUZ_DEBUG
        //std::cout << "but not deleting data" << std::endl;
#endif
    }
    return 0;
}

// tostring() -> userdata 0xHHHHH (puz.Puzzle 0xHHHH)
int Puzzle_tostring(lua_State * L)
{
    Puzzle_ud * ud = luapuz_checkPuzzle_ud(L, 1);
    lua_pushfstring(L, "userdata: %p (%s: %p gc = %s)", ud, Puzzle_meta, ud->puzzle, ud->should_gc ? "true" : "false");
    return 1;
}

// Puzzle functions
//----------------
// Puzzle()
// Puzzle(const std::string & filename)
// Puzzle(const std::string & filename, const FileHandlerDesc * desc)
int Puzzle_Puzzle_try(lua_State * L)
{
    try {
        puz::Puzzle * returns;

        // metatable is first argument
        int argCount = lua_gettop(L) - 1;
        if (argCount >= 2)
        {
            const char * filename = luaL_checkstring(L, 2);
            luaL_checktype(L, 3, LUA_TFUNCTION);

            // Push the function for luapuz_Load_Puzzle.
            lua_pushvalue(L, 3); // Function

            // Create the puz::Puzzle file handler
            puz::Puzzle::FileHandlerDesc desc;
            desc.data = L;
            desc.handler = luapuz_Load_Puzzle;

            // Call the constructor
            returns = new puz::Puzzle(filename, &desc);
        }
        else if (argCount >= 1)
        {
            const char * filename = luaL_checkstring(L, 2);
            returns = new puz::Puzzle(filename);
        }
        else if (argCount >= 0)
        {
            returns = new puz::Puzzle();
        }

        luapuz_newPuzzle(L, returns);
        return 1;
    }
    catch (...) {
        luapuz_handleExceptions(L);
    }
    return -1; // Error on the stack
}

int Puzzle_Puzzle(lua_State * L)
{
    int code = Puzzle_Puzzle_try(L);
    if (code == -1)
        lua_error(L);
    return code;
}
// void Load(const std::string & filename)
// void Load(const std::string & filename, FileHandlerDesc * desc)
int Puzzle_Load_try(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    const char * filename = luaL_checkstring(L, 2);
    try {
        int argCount = lua_gettop(L) - 1;
        if (argCount >= 2)
        {
            luaL_checktype(L, 3, LUA_TFUNCTION);

            // Push the function for luapuz_Load_Puzzle.
            lua_pushvalue(L, 3); // Function

            // Create the puz::Puzzle file handler
            puz::Puzzle::FileHandlerDesc desc;
            desc.data = L;
            desc.handler = luapuz_Load_Puzzle;

            // Call Load()
            puzzle->Load(filename, &desc);
        }
        else
        {
            puzzle->Load(filename);
        }
        return 0;
    }
    catch (...) {
        luapuz_handleExceptions(L);
    }
    return -1; // Error on the stack
}

int Puzzle_Load(lua_State * L)
{
    int code = Puzzle_Load_try(L);
    if (code == -1)
        lua_error(L);
    return code;
}
// void Save(const std::string & filename)
// void Save(const std::string & filename, FileHandlerDesc * desc)
int Puzzle_Save(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    const char * filename = luaL_checkstring(L, 2);
    try {
        int argCount = lua_gettop(L) - 1;
        if (argCount >= 2)
        {
            luaL_checktype(L, 3, LUA_TFUNCTION);

            // Push the function for luapuz_Save_Puzzle.
            lua_pushvalue(L, 3); // Function

            // Create the puz::Puzzle file handler
            puz::Puzzle::FileHandlerDesc desc;
            desc.data = L;
            desc.handler = luapuz_Save_Puzzle;

            // Call Save()
            puzzle->Save(filename, &desc);
        }
        else
        {
            puzzle->Save(filename);
        }
        return 0;
    }
    catch (...) {
        luapuz_handleExceptions(L);
    }
    lua_error(L); // We should have returned by now
    return 0;
}
// static bool CanLoad(const char * filename)
static int Puzzle_CanLoad(lua_State * L)
{
    const char * filename = luaL_checkstring(L, 1);
    bool returns = puz::Puzzle::CanLoad(filename);
    lua_pushboolean(L, returns);
    return 1;
}
// static bool CanSave(const char * filename)
static int Puzzle_CanSave(lua_State * L)
{
    const char * filename = luaL_checkstring(L, 1);
    bool returns = puz::Puzzle::CanSave(filename);
    lua_pushboolean(L, returns);
    return 1;
}
// void Clear()
static int Puzzle_Clear(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puzzle->Clear();
    return 0;
}
// short IsDiagramless()
static int Puzzle_IsDiagramless(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    short returns = puzzle->IsDiagramless();
    lua_pushnumber(L, returns);
    return 1;
}
// bool IsScrambled()
static int Puzzle_IsScrambled(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    bool returns = puzzle->IsScrambled();
    lua_pushboolean(L, returns);
    return 1;
}
// bool IsOk()
static int Puzzle_IsOk(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    bool returns = puzzle->IsOk();
    lua_pushboolean(L, returns);
    return 1;
}
// void SetOk(bool ok)
static int Puzzle_SetOk(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    bool ok = luapuz_checkboolean(L, 2);
    puzzle->SetOk(ok);
    return 0;
}
// void TestOk()
// Separate try/catch function
static int Puzzle_TestOk_try(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    try {
        puzzle->TestOk();
        return 0;
    }
    catch (...) {
        luapuz_handleExceptions(L);
    }
    return -1; // An error is on the stack
}
// The lua function (no exceptions)
static int Puzzle_TestOk(lua_State * L)
{
    int code = Puzzle_TestOk_try(L);
    if (code == -1)
        lua_error(L);
    return code;
}
// Grid & GetGrid()
static int Puzzle_GetGrid(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::Grid * returns = &puzzle->GetGrid();
    luapuz_pushGrid(L, returns);
    return 1;
}
// void SetGrid(puz::Grid & grid)
static int Puzzle_SetGrid(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::Grid * grid = luapuz_checkGrid(L, 2);
    puzzle->SetGrid(*grid);
    return 0;
}
// Puzzle::metamap_t GetMetadata()
static int Puzzle_GetMetadata(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::Puzzle::metamap_t * returns = &puzzle->GetMetadata();
    luapuz_push_metamap_t(L, returns);
    return 1;
}
// puz::string_t GetMeta(puz::string_t name)
static int Puzzle_GetMeta(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::string_t name = luapuz_checkstring_t(L, 2);
    puz::string_t returns = puzzle->GetMeta(name);
    luapuz_pushstring_t(L, returns);
    return 1;
}
// void SetMeta(puz::string_t name, puz::string_t value)
static int Puzzle_SetMeta(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::string_t name = luapuz_checkstring_t(L, 2);
    puz::string_t value = luapuz_checkstring_t(L, 3);
    puzzle->SetMeta(name, value);
    return 0;
}
// bool HasMeta(puz::string_t name)
static int Puzzle_HasMeta(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::string_t name = luapuz_checkstring_t(L, 2);
    bool returns = puzzle->HasMeta(name);
    lua_pushboolean(L, returns);
    return 1;
}
// puz::string_t GetAuthor()
static int Puzzle_GetAuthor(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::string_t returns = puzzle->GetAuthor();
    luapuz_pushstring_t(L, returns);
    return 1;
}
// void SetAuthor(puz::string_t author)
static int Puzzle_SetAuthor(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::string_t author = luapuz_checkstring_t(L, 2);
    puzzle->SetAuthor(author);
    return 0;
}
// puz::string_t GetTitle()
static int Puzzle_GetTitle(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::string_t returns = puzzle->GetTitle();
    luapuz_pushstring_t(L, returns);
    return 1;
}
// void SetTitle(puz::string_t title)
static int Puzzle_SetTitle(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::string_t title = luapuz_checkstring_t(L, 2);
    puzzle->SetTitle(title);
    return 0;
}
// puz::string_t GetCopyright()
static int Puzzle_GetCopyright(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::string_t returns = puzzle->GetCopyright();
    luapuz_pushstring_t(L, returns);
    return 1;
}
// void SetCopyright(puz::string_t copyright)
static int Puzzle_SetCopyright(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::string_t copyright = luapuz_checkstring_t(L, 2);
    puzzle->SetCopyright(copyright);
    return 0;
}
// puz::string_t GetNotes()
static int Puzzle_GetNotes(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::string_t returns = puzzle->GetNotes();
    luapuz_pushstring_t(L, returns);
    return 1;
}
// void SetNotes(puz::string_t notes)
static int Puzzle_SetNotes(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::string_t notes = luapuz_checkstring_t(L, 2);
    puzzle->SetNotes(notes);
    return 0;
}
// int GetTime()
static int Puzzle_GetTime(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    int returns = puzzle->GetTime();
    lua_pushnumber(L, returns);
    return 1;
}
// void SetTime(int time)
static int Puzzle_SetTime(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    int time = luaL_checknumber(L, 2);
    puzzle->SetTime(time);
    return 0;
}
// bool IsTimerRunning()
static int Puzzle_IsTimerRunning(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    bool returns = puzzle->IsTimerRunning();
    lua_pushboolean(L, returns);
    return 1;
}
// void SetTimerRunning(bool running)
static int Puzzle_SetTimerRunning(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    bool running = luapuz_checkboolean(L, 2);
    puzzle->SetTimerRunning(running);
    return 0;
}
// Clues & GetClues()
static int Puzzle_GetClues(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::Clues * returns = &puzzle->GetClues();
    luapuz_pushClues(L, returns);
    return 1;
}
// ClueList & GetClueList(puz::string_t name)
// Separate try/catch function
static int Puzzle_GetClueList_try(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::string_t name = luapuz_checkstring_t(L, 2);
    puz::ClueList * returns;
    try {
        returns = &puzzle->GetClueList(name);
        luapuz_pushClueList(L, returns);
        return 1;
    }
    catch (...) {
        luapuz_handleExceptions(L);
    }
    return -1; // An error is on the stack
}
// The lua function (no exceptions)
static int Puzzle_GetClueList(lua_State * L)
{
    int code = Puzzle_GetClueList_try(L);
    if (code == -1)
        lua_error(L);
    return code;
}
// ClueList & SetClueList(puz::string_t name, puz::ClueList & cluelist)
static int Puzzle_SetClueList(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puz::string_t name = luapuz_checkstring_t(L, 2);
    puz::ClueList cluelist;
    luapuz_checkClueList(L, 3, &cluelist);
    puz::ClueList * returns = &puzzle->SetClueList(name, cluelist);
    luapuz_pushClueList(L, returns);
    return 1;
}
// void NumberClues()
// Separate try/catch function
static int Puzzle_NumberClues_try(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    try {
        puzzle->NumberClues();
        return 0;
    }
    catch (...) {
        luapuz_handleExceptions(L);
    }
    return -1; // An error is on the stack
}
// The lua function (no exceptions)
static int Puzzle_NumberClues(lua_State * L)
{
    int code = Puzzle_NumberClues_try(L);
    if (code == -1)
        lua_error(L);
    return code;
}
// void NumberGrid()
static int Puzzle_NumberGrid(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    puzzle->NumberGrid();
    return 0;
}
// bool UsesNumberAlgorithm()
static int Puzzle_UsesNumberAlgorithm(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    bool returns = puzzle->UsesNumberAlgorithm();
    lua_pushboolean(L, returns);
    return 1;
}
// void GenerateWords()
// Separate try/catch function
static int Puzzle_GenerateWords_try(lua_State * L)
{
    puz::Puzzle * puzzle = luapuz_checkPuzzle(L, 1);
    try {
        puzzle->GenerateWords();
        return 0;
    }
    catch (...) {
        luapuz_handleExceptions(L);
    }
    return -1; // An error is on the stack
}
// The lua function (no exceptions)
static int Puzzle_GenerateWords(lua_State * L)
{
    int code = Puzzle_GenerateWords_try(L);
    if (code == -1)
        lua_error(L);
    return code;
}
static const luaL_reg Puzzlelib[] = {
    {"Load", Puzzle_Load},
    {"Save", Puzzle_Save},
    {"CanLoad", Puzzle_CanLoad},
    {"CanSave", Puzzle_CanSave},
    {"Clear", Puzzle_Clear},
    {"IsDiagramless", Puzzle_IsDiagramless},
    {"IsScrambled", Puzzle_IsScrambled},
    {"IsOk", Puzzle_IsOk},
    {"SetOk", Puzzle_SetOk},
    {"TestOk", Puzzle_TestOk},
    {"GetGrid", Puzzle_GetGrid},
    {"SetGrid", Puzzle_SetGrid},
    {"GetMetadata", Puzzle_GetMetadata},
    {"GetMeta", Puzzle_GetMeta},
    {"SetMeta", Puzzle_SetMeta},
    {"HasMeta", Puzzle_HasMeta},
    {"GetAuthor", Puzzle_GetAuthor},
    {"SetAuthor", Puzzle_SetAuthor},
    {"GetTitle", Puzzle_GetTitle},
    {"SetTitle", Puzzle_SetTitle},
    {"GetCopyright", Puzzle_GetCopyright},
    {"SetCopyright", Puzzle_SetCopyright},
    {"GetNotes", Puzzle_GetNotes},
    {"SetNotes", Puzzle_SetNotes},
    {"GetTime", Puzzle_GetTime},
    {"SetTime", Puzzle_SetTime},
    {"IsTimerRunning", Puzzle_IsTimerRunning},
    {"SetTimerRunning", Puzzle_SetTimerRunning},
    {"GetClues", Puzzle_GetClues},
    {"GetClueList", Puzzle_GetClueList},
    {"SetClueList", Puzzle_SetClueList},
    {"NumberClues", Puzzle_NumberClues},
    {"NumberGrid", Puzzle_NumberGrid},
    {"UsesNumberAlgorithm", Puzzle_UsesNumberAlgorithm},
    {"GenerateWords", Puzzle_GenerateWords},
    {NULL, NULL}
};

const luaL_reg classPuzzlelib[] = {
    { "__gc",        Puzzle_gc },
    { "__index",     luapuz_index },
    { "__newindex",  luapuz_newindex },
    { "__tostring",  Puzzle_tostring },
    { NULL, NULL }
};

void luapuz_openPuzzlelib (lua_State *L) {
    // The Puzzle table, and the metatable for Puzzle objects
    luaL_newmetatable(L, Puzzle_meta);

    // register metatable functions
    luaL_register(L, NULL, Puzzlelib);
    luaL_register(L, NULL, classPuzzlelib);
    // Register constructor
    luapuz_registerConstructor(L, Puzzle_Puzzle);

    // puz.Puzzle = the table
    lua_setfield(L, -2, "Puzzle");
}
