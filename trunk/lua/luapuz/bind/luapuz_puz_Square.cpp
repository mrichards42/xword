// ---------------------------------------------------------------------------
// luapuz_puz_Square.cpp was generated by puzbind.lua
//
// Any changes made to this file will be lost when the file is regenerated.
// ---------------------------------------------------------------------------

extern "C" {
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
}

#include "../luapuz_functions.hpp"
#include "../luapuz_tracking.hpp"

#include "luapuz_puz.hpp"
#include "luapuz_puz_Square.hpp"
// ---------------------------------------------------------------------------
// class Square
// ---------------------------------------------------------------------------



const char * Square_meta = "puz.Square";

// Create a new userdata with actual data and push it on the stack.
// The userdata will be tracked in the tracked objects table.
LUAPUZ_API void luapuz_newSquare(lua_State * L,
                               puz::Square * square,
                               bool should_gc)
{
    // Create the userdata
    Square_ud * ud =
        (Square_ud *)lua_newuserdata(L, sizeof(Square_ud));

    ud->should_gc = should_gc;

    // Set the data member
    ud->square = square;

    // Set the metatable
    luaL_getmetatable(L, Square_meta);
    lua_setmetatable(L, -2);

    // Track the object
    luapuz_track_object(L, square);
}



// Delete the data on garbage collection
int Square_gc(lua_State * L)
{
#ifdef LUAPUZ_DEBUG
    std::cout << "Garbage collecting puz::Square ";
#endif
    Square_ud * ud = luapuz_checkSquare_ud(L, 1);
    luapuz_untrack_object(L, ud->square);
    if (ud->should_gc)
    {
        delete ud->square;
#ifdef LUAPUZ_DEBUG
        std::cout << "and deleting data" << std::endl;
#endif
    }
    else
    {
#ifdef LUAPUZ_DEBUG
        //std::cout << "but not deleting data" << std::endl;
#endif
    }
    return 0;
}

// tostring() -> userdata 0xHHHHH (puz.Square 0xHHHH)
int Square_tostring(lua_State * L)
{
    Square_ud * ud = luapuz_checkSquare_ud(L, 1);
    lua_pushfstring(L, "userdata: %p (%s: %p gc = %s)", ud, Square_meta, ud->square, ud->should_gc ? "true" : "false");
    return 1;
}

// Square functions
//----------------
// short GetCol()
static int Square_GetCol(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    // Adjust to a lua index (1-based)
    short returns = square->GetCol() + 1;
    lua_pushnumber(L, returns);
    return 1;
}
// short GetRow()
static int Square_GetRow(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    // Adjust to a lua index (1-based)
    short returns = square->GetRow() + 1;
    lua_pushnumber(L, returns);
    return 1;
}
// bool IsLast(puz::GridDirection dir, puz::FindDirection inc = puz::NEXT)
static int Square_IsLast(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    int argCount = lua_gettop(L);
    puz::GridDirection dir = luapuz_checkGridDirection(L, 2);
    puz::FindDirection inc = (argCount >= 3 ? luapuz_checkFindDirection(L, 3) : puz::NEXT);
    bool returns = square->IsLast(dir, inc);
    lua_pushboolean(L, returns);
    return 1;
}
// bool IsFirst(puz::GridDirection dir, puz::FindDirection inc = puz::NEXT)
static int Square_IsFirst(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    int argCount = lua_gettop(L);
    puz::GridDirection dir = luapuz_checkGridDirection(L, 2);
    puz::FindDirection inc = (argCount >= 3 ? luapuz_checkFindDirection(L, 3) : puz::NEXT);
    bool returns = square->IsFirst(dir, inc);
    lua_pushboolean(L, returns);
    return 1;
}
// bool IsWhite()
static int Square_IsWhite(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    bool returns = square->IsWhite();
    lua_pushboolean(L, returns);
    return 1;
}
// bool IsBlack()
static int Square_IsBlack(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    bool returns = square->IsBlack();
    lua_pushboolean(L, returns);
    return 1;
}
// bool IsBlank()
static int Square_IsBlank(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    bool returns = square->IsBlank();
    lua_pushboolean(L, returns);
    return 1;
}
// std::string GetText()
static int Square_GetText(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    std::string returns = square->GetText();
    luapuz_pushStdString(L, returns);
    return 1;
}
// char GetPlainText()
static int Square_GetPlainText(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    char returns = square->GetPlainText();
    luapuz_pushchar(L, returns);
    return 1;
}
// unsigned short GetTextSymbol()
static int Square_GetTextSymbol(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    unsigned short returns;
    try {
        returns = square->GetTextSymbol();
        lua_pushnumber(L, returns);
        return 1;
    }
    catch (...) {
        luapuz_handleExceptions(L);
        return 0;
    }
}
// void SetText(std::string text)
static int Square_SetText(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    std::string text = luapuz_checkStdString(L, 2);
    try {
        square->SetText(text);
        return 0;
    }
    catch (...) {
        luapuz_handleExceptions(L);
        return 0;
    }
}
// bool HasTextRebus()
static int Square_HasTextRebus(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    bool returns = square->HasTextRebus();
    lua_pushboolean(L, returns);
    return 1;
}
// bool HasTextSymbol()
static int Square_HasTextSymbol(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    bool returns = square->HasTextSymbol();
    lua_pushboolean(L, returns);
    return 1;
}
// std::string GetSolution()
static int Square_GetSolution(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    std::string returns = square->GetSolution();
    luapuz_pushStdString(L, returns);
    return 1;
}
// char GetPlainSolution()
static int Square_GetPlainSolution(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    char returns = square->GetPlainSolution();
    luapuz_pushchar(L, returns);
    return 1;
}
// unsigned short GetSolutionSymbol()
static int Square_GetSolutionSymbol(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    unsigned short returns;
    try {
        returns = square->GetSolutionSymbol();
        lua_pushnumber(L, returns);
        return 1;
    }
    catch (...) {
        luapuz_handleExceptions(L);
        return 0;
    }
}
// void SetSolution(std::string solution)
static int Square_SetSolution1(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    std::string solution = luapuz_checkStdString(L, 2);
    try {
        square->SetSolution(solution);
        return 0;
    }
    catch (...) {
        luapuz_handleExceptions(L);
        return 0;
    }
}
// void SetSolution(std::string solution, char plain)
static int Square_SetSolution2(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    std::string solution = luapuz_checkStdString(L, 2);
    char plain = luapuz_checkchar(L, 3);
    try {
        square->SetSolution(solution, plain);
        return 0;
    }
    catch (...) {
        luapuz_handleExceptions(L);
        return 0;
    }
}
// SetSolution overload resolution
static int Square_SetSolution(lua_State * L)
{

    luapuz_checkSquare(L, 1);
    int argCount = lua_gettop(L) - 1;
    if (argCount >= 2)
    {
        // Only one function
        return Square_SetSolution2(L);
    }
    else if (argCount >= 1)
    {
        // Only one function
        return Square_SetSolution1(L);
    }
    // Else we didn't find a function
    luaL_error(L, "Unable to find overload");
    return 0;
}

// void SetPlainSolution(char plain)
static int Square_SetPlainSolution(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    char plain = luapuz_checkchar(L, 2);
    square->SetPlainSolution(plain);
    return 0;
}
// void SetSolutionRebus(std::string rebus)
static int Square_SetSolutionRebus(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    std::string rebus = luapuz_checkStdString(L, 2);
    try {
        square->SetSolutionRebus(rebus);
        return 0;
    }
    catch (...) {
        luapuz_handleExceptions(L);
        return 0;
    }
}
// void SetSolutionSymbol(unsigned short symbol)
static int Square_SetSolutionSymbol(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    unsigned short symbol = luapuz_checkuint(L, 2);
    try {
        square->SetSolutionSymbol(symbol);
        return 0;
    }
    catch (...) {
        luapuz_handleExceptions(L);
        return 0;
    }
}
// bool HasSolutionRebus()
static int Square_HasSolutionRebus(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    bool returns = square->HasSolutionRebus();
    lua_pushboolean(L, returns);
    return 1;
}
// bool HasSolutionSymbol()
static int Square_HasSolutionSymbol(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    bool returns = square->HasSolutionSymbol();
    lua_pushboolean(L, returns);
    return 1;
}
// bool Check(bool checkBlank)
static int Square_Check(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    bool checkBlank = luapuz_checkboolean(L, 2);
    bool returns = square->Check(checkBlank);
    lua_pushboolean(L, returns);
    return 1;
}
// short GetNumber()
static int Square_GetNumber(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    short returns = square->GetNumber();
    lua_pushnumber(L, returns);
    return 1;
}
// bool HasClue()
static int Square_HasClue1(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    bool returns = square->HasClue();
    lua_pushboolean(L, returns);
    return 1;
}
// bool HasClue(puz::GridDirection dir)
static int Square_HasClue2(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    puz::GridDirection dir = luapuz_checkGridDirection(L, 2);
    bool returns = square->HasClue(dir);
    lua_pushboolean(L, returns);
    return 1;
}
// HasClue overload resolution
static int Square_HasClue(lua_State * L)
{

    luapuz_checkSquare(L, 1);
    int argCount = lua_gettop(L) - 1;
    if (argCount >= 1)
    {
        // Only one function
        return Square_HasClue2(L);
    }
    else if (argCount >= 0)
    {
        // Only one function
        return Square_HasClue1(L);
    }
    // Else we didn't find a function
    luaL_error(L, "Unable to find overload");
    return 0;
}

// void SetFlag(unsigned char flag)
static int Square_SetFlag(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    unsigned char flag = luapuz_checkuint(L, 2);
    square->SetFlag(flag);
    return 0;
}
// void AddFlag(unsigned char flag)
static int Square_AddFlag(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    unsigned char flag = luapuz_checkuint(L, 2);
    square->AddFlag(flag);
    return 0;
}
// void RemoveFlag(unsigned char flag)
static int Square_RemoveFlag(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    unsigned char flag = luapuz_checkuint(L, 2);
    square->RemoveFlag(flag);
    return 0;
}
// void ToggleFlag(unsigned char flag)
static int Square_ToggleFlag(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    unsigned char flag = luapuz_checkuint(L, 2);
    square->ToggleFlag(flag);
    return 0;
}
// unsigned char GetFlag()
static int Square_GetFlag(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    unsigned char returns = square->GetFlag();
    lua_pushnumber(L, returns);
    return 1;
}
// bool HasFlag(unsigned char flag)
static int Square_HasFlag(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    unsigned char flag = luapuz_checkuint(L, 2);
    bool returns = square->HasFlag(flag);
    lua_pushboolean(L, returns);
    return 1;
}
// void ReplaceFlag(unsigned char flag1, unsigned char flag2)
static int Square_ReplaceFlag(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    unsigned char flag1 = luapuz_checkuint(L, 2);
    unsigned char flag2 = luapuz_checkuint(L, 3);
    square->ReplaceFlag(flag1, flag2);
    return 0;
}
// Square * Next(puz::GridDirection dir = puz::ACROSS, puz::FindDirection inc = puz::NEXT)
static int Square_Next(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    int argCount = lua_gettop(L);
    puz::GridDirection dir = (argCount >= 2 ? luapuz_checkGridDirection(L, 2) : puz::ACROSS);
    puz::FindDirection inc = (argCount >= 3 ? luapuz_checkFindDirection(L, 3) : puz::NEXT);
    puz::Square * returns = square->Next(dir, inc);
    luapuz_pushSquare(L, returns);
    return 1;
}
// Square * Prev(puz::GridDirection dir = puz::ACROSS, puz::FindDirection inc = puz::NEXT)
static int Square_Prev(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    int argCount = lua_gettop(L);
    puz::GridDirection dir = (argCount >= 2 ? luapuz_checkGridDirection(L, 2) : puz::ACROSS);
    puz::FindDirection inc = (argCount >= 3 ? luapuz_checkFindDirection(L, 3) : puz::NEXT);
    puz::Square * returns = square->Prev(dir, inc);
    luapuz_pushSquare(L, returns);
    return 1;
}
// Square * GetWordStart(puz::GridDirection dir)
static int Square_GetWordStart(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    puz::GridDirection dir = luapuz_checkGridDirection(L, 2);
    puz::Square * returns = square->GetWordStart(dir);
    luapuz_pushSquare(L, returns);
    return 1;
}
// Square * GetWordEnd(puz::GridDirection dir)
static int Square_GetWordEnd(lua_State * L)
{
    puz::Square * square = luapuz_checkSquare(L, 1);
    puz::GridDirection dir = luapuz_checkGridDirection(L, 2);
    puz::Square * returns = square->GetWordEnd(dir);
    luapuz_pushSquare(L, returns);
    return 1;
}
// static bool IsValidString(std::string str)
static int Square_IsValidString(lua_State * L)
{
    std::string str = luapuz_checkStdString(L, 1);
    bool returns = puz::Square::IsValidString(str);
    lua_pushboolean(L, returns);
    return 1;
}
// static bool IsValidChar(char ch)
static int Square_IsValidChar(lua_State * L)
{
    char ch = luapuz_checkchar(L, 1);
    bool returns = puz::Square::IsValidChar(ch);
    lua_pushboolean(L, returns);
    return 1;
}
// static bool IsSymbol(std::string str)
static int Square_IsSymbol(lua_State * L)
{
    std::string str = luapuz_checkStdString(L, 1);
    bool returns = puz::Square::IsSymbol(str);
    lua_pushboolean(L, returns);
    return 1;
}
static const luaL_reg Squarelib[] = {
    {"GetCol", Square_GetCol},
    {"GetRow", Square_GetRow},
    {"IsLast", Square_IsLast},
    {"IsFirst", Square_IsFirst},
    {"IsWhite", Square_IsWhite},
    {"IsBlack", Square_IsBlack},
    {"IsBlank", Square_IsBlank},
    {"GetText", Square_GetText},
    {"GetPlainText", Square_GetPlainText},
    {"GetTextSymbol", Square_GetTextSymbol},
    {"SetText", Square_SetText},
    {"HasTextRebus", Square_HasTextRebus},
    {"HasTextSymbol", Square_HasTextSymbol},
    {"GetSolution", Square_GetSolution},
    {"GetPlainSolution", Square_GetPlainSolution},
    {"GetSolutionSymbol", Square_GetSolutionSymbol},
    {"SetSolution", Square_SetSolution},
    {"SetPlainSolution", Square_SetPlainSolution},
    {"SetSolutionRebus", Square_SetSolutionRebus},
    {"SetSolutionSymbol", Square_SetSolutionSymbol},
    {"HasSolutionRebus", Square_HasSolutionRebus},
    {"HasSolutionSymbol", Square_HasSolutionSymbol},
    {"Check", Square_Check},
    {"GetNumber", Square_GetNumber},
    {"HasClue", Square_HasClue},
    {"SetFlag", Square_SetFlag},
    {"AddFlag", Square_AddFlag},
    {"RemoveFlag", Square_RemoveFlag},
    {"ToggleFlag", Square_ToggleFlag},
    {"GetFlag", Square_GetFlag},
    {"HasFlag", Square_HasFlag},
    {"ReplaceFlag", Square_ReplaceFlag},
    {"Next", Square_Next},
    {"Prev", Square_Prev},
    {"GetWordStart", Square_GetWordStart},
    {"GetWordEnd", Square_GetWordEnd},
    {"IsValidString", Square_IsValidString},
    {"IsValidChar", Square_IsValidChar},
    {"IsSymbol", Square_IsSymbol},
    {NULL, NULL}
};

const luaL_reg staticSquarelib[] = {
    {"IsValidString", Square_IsValidString},
    {"IsValidChar", Square_IsValidChar},
    {"IsSymbol", Square_IsSymbol},
    {NULL, NULL}
};

const luaL_reg classSquarelib[] = {
    { "__gc",        Square_gc },
    { "__index",     luapuz_index },
    { "__newindex",  luapuz_newindex },
    { "__tostring",  Square_tostring },
    { NULL, NULL }
};

void luapuz_openSquarelib (lua_State *L) {
    luaL_newmetatable(L, Square_meta);

    // register metatable functions
    luaL_register(L, NULL, Squarelib);
    luaL_register(L, NULL, classSquarelib);

    // remove metatable from stack
    lua_pop(L, 1);

    // puz.Square table
    lua_newtable(L);
    luaL_register(L, NULL, staticSquarelib);
    // puz.Square = the table
    lua_setfield(L, -2, "Square");
}
