// ---------------------------------------------------------------------------
// luapuz_puz_Grid.cpp was generated by puzbind.lua
//
// Any changes made to this file will be lost when the file is regenerated.
// ---------------------------------------------------------------------------

extern "C" {
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
}

#include "../luapuz_functions.hpp"
#include "../luapuz_tracking.hpp"

#include "luapuz_puz_Square.hpp"
#include "luapuz_puz.hpp"
#include "luapuz_std.hpp"
#include "luapuz_puz_Grid.hpp"
// ---------------------------------------------------------------------------
// class Grid
// ---------------------------------------------------------------------------



const char * Grid_meta = "puz.Grid";

// Create a new userdata with actual data and push it on the stack.
// The userdata will be tracked in the tracked objects table.
LUAPUZ_API void luapuz_newGrid(lua_State * L,
                               puz::Grid * grid,
                               bool should_gc)
{
    // Create the userdata
    Grid_ud * ud =
        (Grid_ud *)lua_newuserdata(L, sizeof(Grid_ud));

    ud->should_gc = should_gc;

    // Set the data member
    ud->grid = grid;

    // Set the metatable
    luaL_getmetatable(L, Grid_meta);
    lua_setmetatable(L, -2);

    // Track the object
    luapuz_track_object(L, grid);
}



// Delete the data on garbage collection
int Grid_gc(lua_State * L)
{
#ifdef LUAPUZ_DEBUG
    std::cout << "Garbage collecting puz::Grid ";
#endif
    Grid_ud * ud = luapuz_checkGrid_ud(L, 1);
    luapuz_untrack_object(L, ud->grid);
    if (ud->should_gc)
    {
        // If the user calls Grid:__gc() before this object
        // is garbage collected, we might try to delete ud->grid twice.
        ud->should_gc = false;
        delete ud->grid;
#ifdef LUAPUZ_DEBUG
        std::cout << "and deleting data" << std::endl;
#endif
    }
    else
    {
#ifdef LUAPUZ_DEBUG
        //std::cout << "but not deleting data" << std::endl;
#endif
    }
    return 0;
}

// tostring() -> userdata 0xHHHHH (puz.Grid 0xHHHH)
int Grid_tostring(lua_State * L)
{
    Grid_ud * ud = luapuz_checkGrid_ud(L, 1);
    lua_pushfstring(L, "userdata: %p (%s: %p gc = %s)", ud, Grid_meta, ud->grid, ud->should_gc ? "true" : "false");
    return 1;
}

// Grid functions
//----------------
// puz::Square * Grid[{col, row}]
static int Grid__index(lua_State * L)
{
    // Grid can be indexed using Grid[{col, row}]
    // Indices start from 1 (as expected in lua)

    puz::Grid * grid = luapuz_checkGrid(L, 1);

    luaL_checktype(L, 2, LUA_TTABLE);

    lua_pushnumber(L, 1);
    lua_gettable(L, 2);
    size_t col = luapuz_checkuint(L, -1);

    lua_pushnumber(L, 2);
    lua_gettable(L, 2);
    size_t row = luapuz_checkuint(L, -1);

    try
    {
        // Adjust the lua indices to C indices (1-based to 0-based).
        puz::Square * returns = &grid->At(col - 1, row - 1);
        luapuz_pushSquare(L, returns);
        return 1;
    }
    catch (std::exception &)
    {
        luaL_error(L,
                   "Grid indices out of bounds: "
                   "1 <= col <= %d and 1 <= row <= %d",
                   grid->LastCol() + 1,
                   grid->LastRow() + 1);
        return 0;
    }
}
// void Grid[{col, row}] = puz::Square *
static int Grid__newindex(lua_State * L)
{
    // Grid squares can be set as follows:
    //     Grid[{col, row}] = Square
    // Indices start from 1 (as expected in lua)

    puz::Grid * grid = luapuz_checkGrid(L, 1);

    luaL_checktype(L, 2, LUA_TTABLE);

    puz::Square * square = luapuz_checkSquare(L, 3);

    lua_pushnumber(L, 1);
    lua_gettable(L, 2);
    size_t col = luapuz_checkuint(L, -1);

    lua_pushnumber(L, 2);
    lua_gettable(L, 2);
    size_t row = luapuz_checkuint(L, -1);

    try
    {
        // Adjust the lua indices to C indices (1-based to 0-based).
        grid->At(col - 1, row - 1) = *square;
        return 0;
    }
    catch (std::exception &)
    {
        luaL_error(L,
                   "Grid indices out of bounds: "
                   "1 <= col <= %d and 1 <= row <= %d",
                   grid->LastCol() + 1,
                   grid->LastRow() + 1);
        return 0;
    }
}
// Grid * Grid(size_t width = 0, size_t height = 0)
static int Grid_Grid(lua_State * L)
{
    int argCount = lua_gettop(L);
    size_t width = (argCount >= 2 ? luapuz_checkuint(L, 2) : 0);
    size_t height = (argCount >= 3 ? luapuz_checkuint(L, 3) : 0);
    puz::Grid * returns = new puz::Grid(width, height);
    luapuz_newGrid(L, returns);
    return 1;
}
// void NumberGrid()
static int Grid_NumberGrid(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    grid->NumberGrid();
    return 0;
}
// void SetSize(size_t width, size_t height)
static int Grid_SetSize(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    size_t width = luapuz_checkuint(L, 2);
    size_t height = luapuz_checkuint(L, 3);
    grid->SetSize(width, height);
    return 0;
}
// size_t GetWidth()
static int Grid_GetWidth(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    size_t returns = grid->GetWidth();
    lua_pushnumber(L, returns);
    return 1;
}
// size_t GetHeight()
static int Grid_GetHeight(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    size_t returns = grid->GetHeight();
    lua_pushnumber(L, returns);
    return 1;
}
// int LastRow()
static int Grid_LastRow(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    int returns = grid->LastRow() + 1; // Lua indices are 1-based
    lua_pushnumber(L, returns);
    return 1;
}
// int LastCol()
static int Grid_LastCol(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    int returns = grid->LastCol() + 1; // Lua indices are 1-based
    lua_pushnumber(L, returns);
    return 1;
}
// bool IsEmpty()
static int Grid_IsEmpty(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    bool returns = grid->IsEmpty();
    lua_pushboolean(L, returns);
    return 1;
}
// void Clear()
static int Grid_Clear(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    grid->Clear();
    return 0;
}
// Square * First()
static int Grid_First(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    puz::Square * returns = grid->First();
    luapuz_pushSquare(L, returns);
    return 1;
}
// Square * Last()
static int Grid_Last(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    puz::Square * returns = grid->Last();
    luapuz_pushSquare(L, returns);
    return 1;
}
// bool IsScrambled()
static int Grid_IsScrambled(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    bool returns = grid->IsScrambled();
    lua_pushboolean(L, returns);
    return 1;
}
// bool HasSolution()
static int Grid_HasSolution(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    bool returns = grid->HasSolution();
    lua_pushboolean(L, returns);
    return 1;
}
// unsigned short GetFlag()
static int Grid_GetFlag(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short returns = grid->GetFlag();
    lua_pushnumber(L, returns);
    return 1;
}
// void SetFlag(unsigned short flag)
static int Grid_SetFlag(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short flag = luapuz_checkuint(L, 2);
    grid->SetFlag(flag);
    return 0;
}
// bool IsDiagramless()
static int Grid_IsDiagramless(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    bool returns = grid->IsDiagramless();
    lua_pushboolean(L, returns);
    return 1;
}
// unsigned short GetType()
static int Grid_GetType(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short returns = grid->GetType();
    lua_pushnumber(L, returns);
    return 1;
}
// void SetType(unsigned short type)
static int Grid_SetType(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short type = luapuz_checkuint(L, 2);
    grid->SetType(type);
    return 0;
}
// bool ScrambleSolution(unsigned short key = 0)
static int Grid_ScrambleSolution(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    int argCount = lua_gettop(L);
    unsigned short key = (argCount >= 2 ? luapuz_checkuint(L, 2) : 0);
    bool returns = grid->ScrambleSolution(key);
    lua_pushboolean(L, returns);
    return 1;
}
// bool UnscrambleSolution(unsigned short key)
static int Grid_UnscrambleSolution(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short key = luapuz_checkuint(L, 2);
    bool returns = grid->UnscrambleSolution(key);
    lua_pushboolean(L, returns);
    return 1;
}
// bool CheckScrambledGrid()
static int Grid_CheckScrambledGrid(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    bool returns = grid->CheckScrambledGrid();
    lua_pushboolean(L, returns);
    return 1;
}
// unsigned short GetKey()
static int Grid_GetKey(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short returns = grid->GetKey();
    lua_pushnumber(L, returns);
    return 1;
}
// void SetKey(unsigned short key)
static int Grid_SetKey(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short key = luapuz_checkuint(L, 2);
    grid->SetKey(key);
    return 0;
}
// unsigned short GetCksum()
static int Grid_GetCksum(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short returns = grid->GetCksum();
    lua_pushnumber(L, returns);
    return 1;
}
// void SetCksum(unsigned short cksum)
static int Grid_SetCksum(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short cksum = luapuz_checkuint(L, 2);
    grid->SetCksum(cksum);
    return 0;
}
// { puz::Square*, ... } CheckGrid(bool checkBlank = false, bool strictRebus = false)
static int Grid_CheckGrid(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    int argCount = lua_gettop(L);
    bool checkBlank = (argCount >= 2 ? luapuz_checkboolean(L, 2) : false);
    bool strictRebus = (argCount >= 3 ? luapuz_checkboolean(L, 3) : false);
    std::vector<puz::Square*> returns;
    grid->CheckGrid(&returns, checkBlank, strictRebus);
    luapuz_pushSquareVector(L, &returns);
    return 1;
}
// bool CheckSquare(puz::Square & square, bool checkBlank = false, bool strictRebus = false)
static int Grid_CheckSquare(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    int argCount = lua_gettop(L);
    puz::Square * square = luapuz_checkSquare(L, 2);
    bool checkBlank = (argCount >= 3 ? luapuz_checkboolean(L, 3) : false);
    bool strictRebus = (argCount >= 4 ? luapuz_checkboolean(L, 4) : false);
    bool returns = grid->CheckSquare(*square, checkBlank, strictRebus);
    lua_pushboolean(L, returns);
    return 1;
}
// Helper for FindSquare
struct luapuz_FindSquare_Struct
{
    luapuz_FindSquare_Struct(lua_State * L)
        : m_L(L)
    {}

    lua_State * m_L;

    bool operator() (puz::Square * square)
    {
        // Push the function (on top of the stack)
        // lua_call() pops this function, so we'll make a copy
        // for further iterations.
        lua_pushvalue(m_L, -1);
        luapuz_pushSquare(m_L, square);
        lua_call(m_L, 1, 1);
        bool result = luapuz_checkboolean(m_L, -1);
        lua_pop(m_L, 1); // Pop the result (stack is balanced).
        return result;
    }
};


// FindSquare overloads:
//----------------------
// puz::Square * FindSquare(puz::Square * start, function findFunc,
//                          puz::GridDirection direction = puz::ACROSS,
//                          unsigned int options = puz::FIND_IN_GRID)
//
// puz::Square * FindSquare(function findFunc,
//                          puz::GridDirection direction = puz::ACROSS,
//                          unsigned int options = puz::FIND_IN_GRID)
//
static int Grid_FindSquare(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    int argCount = lua_gettop(L);

    puz::Square * returns;

    if (luapuz_isSquare(L, 2))  // First overload
    {
        puz::Square * start = luapuz_checkSquare(L, 2);
        luaL_checktype(L, 3, LUA_TFUNCTION);
        puz::GridDirection direction = (argCount >= 4 ? luapuz_checkGridDirection(L, 4) : puz::ACROSS);
        unsigned int options = (argCount >= 5 ? luapuz_checkuint(L, 5) : puz::FIND_IN_GRID);

        // Push the function on the stack for luapuz_FindSquare_Struct
        lua_pushvalue(L, 3);
        luapuz_FindSquare_Struct func(L);

        returns = grid->FindSquare(start, func, direction, options);
    }
    else  // Second overload
    {
        luaL_checktype(L, 2, LUA_TFUNCTION);
        puz::GridDirection direction = (argCount >= 3 ? luapuz_checkGridDirection(L, 3) : puz::ACROSS);
        unsigned int options = (argCount >= 4 ? luapuz_checkuint(L, 4) : puz::FIND_IN_GRID);

        // Push the function on the stack for luapuz_FindSquare_Struct
        lua_pushvalue(L, 2);
        luapuz_FindSquare_Struct func(L);

        returns = grid->FindSquare(func, direction, options);
    }

    luapuz_pushSquare(L, returns);
    return 1;
}
static const luaL_reg Gridlib[] = {
    {"_index", Grid__index},
    {"_newindex", Grid__newindex},
    {"NumberGrid", Grid_NumberGrid},
    {"SetSize", Grid_SetSize},
    {"GetWidth", Grid_GetWidth},
    {"GetHeight", Grid_GetHeight},
    {"LastRow", Grid_LastRow},
    {"LastCol", Grid_LastCol},
    {"IsEmpty", Grid_IsEmpty},
    {"Clear", Grid_Clear},
    {"First", Grid_First},
    {"Last", Grid_Last},
    {"IsScrambled", Grid_IsScrambled},
    {"HasSolution", Grid_HasSolution},
    {"GetFlag", Grid_GetFlag},
    {"SetFlag", Grid_SetFlag},
    {"IsDiagramless", Grid_IsDiagramless},
    {"GetType", Grid_GetType},
    {"SetType", Grid_SetType},
    {"ScrambleSolution", Grid_ScrambleSolution},
    {"UnscrambleSolution", Grid_UnscrambleSolution},
    {"CheckScrambledGrid", Grid_CheckScrambledGrid},
    {"GetKey", Grid_GetKey},
    {"SetKey", Grid_SetKey},
    {"GetCksum", Grid_GetCksum},
    {"SetCksum", Grid_SetCksum},
    {"CheckGrid", Grid_CheckGrid},
    {"CheckSquare", Grid_CheckSquare},
    {"FindSquare", Grid_FindSquare},
    {NULL, NULL}
};

const luaL_reg classGridlib[] = {
    { "__gc",        Grid_gc },
    { "__index",     luapuz_index },
    { "__newindex",  luapuz_newindex },
    { "__tostring",  Grid_tostring },
    { NULL, NULL }
};

void luapuz_openGridlib (lua_State *L) {
    // The Grid table, and the metatable for Grid objects
    luaL_newmetatable(L, Grid_meta);

    // register metatable functions
    luaL_register(L, NULL, Gridlib);
    luaL_register(L, NULL, classGridlib);
    // Register constructor
    luapuz_registerConstructor(L, Grid_Grid);

    // puz.Grid = the table
    lua_setfield(L, -2, "Grid");
}
