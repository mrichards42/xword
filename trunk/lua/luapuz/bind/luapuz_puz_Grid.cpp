// ---------------------------------------------------------------------------
// luapuz_puz_Grid.cpp was generated by puzbind.lua
//
// Any changes made to this file will be lost when the file is regenerated.
// ---------------------------------------------------------------------------

extern "C" {
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
}

#include "../luapuz_functions.hpp"
#include "../luapuz_tracking.hpp"

#include "luapuz_puz_Square.hpp"
#include "luapuz_puz_Grid.hpp"
// ---------------------------------------------------------------------------
// class Grid
// ---------------------------------------------------------------------------



const char * Grid_meta = "puz.Grid";

// Create a new userdata with actual data and push it on the stack.
// The userdata will be tracked in the tracked objects table.
LUAPUZ_API void luapuz_newGrid(lua_State * L,
                               puz::Grid * grid,
                               bool should_gc)
{
    // Create the userdata
    Grid_ud * ud =
        (Grid_ud *)lua_newuserdata(L, sizeof(Grid_ud));

    ud->should_gc = should_gc;

    // Set the data member
    ud->grid = grid;

    // Set the metatable
    luaL_getmetatable(L, Grid_meta);
    lua_setmetatable(L, -2);

    // Track the object
    luapuz_track_object(L, grid);
}



// Delete the data on garbage collection
int Grid_gc(lua_State * L)
{
#ifdef LUAPUZ_DEBUG
    std::cout << "Garbage collecting puz::Grid ";
#endif
    Grid_ud * ud = luapuz_checkGrid_ud(L, 1);
    luapuz_untrack_object(L, ud->grid);
    if (ud->should_gc)
    {
        delete ud->grid;
#ifdef LUAPUZ_DEBUG
        std::cout << "and deleting data" << std::endl;
#endif
    }
    else
    {
#ifdef LUAPUZ_DEBUG
        //std::cout << "but not deleting data" << std::endl;
#endif
    }
    return 0;
}

// tostring() -> userdata 0xHHHHH (puz.Grid 0xHHHH)
int Grid_tostring(lua_State * L)
{
    Grid_ud * ud = luapuz_checkGrid_ud(L, 1);
    lua_pushfstring(L, "userdata: %p (%s: %p gc = %s)", ud, Grid_meta, ud->grid, ud->should_gc ? "true" : "false");
    return 1;
}

// Grid functions
//----------------
// puz::Square * Grid[{col, row}]
static int Grid__index(lua_State * L)
{
    // Grid can be indexed using Grid[{col, row}]
    // Indices start from 1 (as expected in lua)

    puz::Grid * grid = luapuz_checkGrid(L, 1);

    luaL_checktype(L, 2, LUA_TTABLE);

    lua_pushnumber(L, 1);
    lua_gettable(L, 2);
    size_t col = luapuz_checkuint(L, -1);

    lua_pushnumber(L, 2);
    lua_gettable(L, 2);
    size_t row = luapuz_checkuint(L, -1);

    try
    {
        // Adjust the lua indices to C indices (1-based to 0-based).
        puz::Square * returns = &grid->At(col - 1, row - 1);
        luapuz_pushSquare(L, returns);
        return 1;
    }
    catch (std::exception &)
    {
        luaL_error(L,
                   "Grid indices out of bounds: "
                   "1 <= col <= %d and 1 <= row <= %d",
                   grid->LastCol() + 1,
                   grid->LastRow() + 1);
        return 0;
    }
}
// void Grid[{col, row}] = puz::Square *
static int Grid__newindex(lua_State * L)
{
    // Grid squares can be set as follows:
    //     Grid[{col, row}] = Square
    // Indices start from 1 (as expected in lua)

    puz::Grid * grid = luapuz_checkGrid(L, 1);

    luaL_checktype(L, 2, LUA_TTABLE);

    puz::Square * square = luapuz_checkSquare(L, 3);

    lua_pushnumber(L, 1);
    lua_gettable(L, 2);
    size_t col = luapuz_checkuint(L, -1);

    lua_pushnumber(L, 2);
    lua_gettable(L, 2);
    size_t row = luapuz_checkuint(L, -1);

    try
    {
        // Adjust the lua indices to C indices (1-based to 0-based).
        grid->At(col - 1, row - 1) = *square;
        return 0;
    }
    catch (std::exception &)
    {
        luaL_error(L,
                   "Grid indices out of bounds: "
                   "1 <= col <= %d and 1 <= row <= %d",
                   grid->LastCol() + 1,
                   grid->LastRow() + 1);
        return 0;
    }
}
// Grid * Grid(size_t width = 0, size_t height = 0)
static int Grid_Grid(lua_State * L)
{
    int argCount = lua_gettop(L);
    size_t width = (argCount >= 2 ? luapuz_checkuint(L, 2) : 0);
    size_t height = (argCount >= 3 ? luapuz_checkuint(L, 3) : 0);
    puz::Grid * returns = new puz::Grid(width, height);
    luapuz_newGrid(L, returns);
    return 1;
}
// bool SetupGrid(puz::Grid::GridState state = puz::Grid::GRID_ALL)
static int Grid_SetupGrid(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    int argCount = lua_gettop(L);
    puz::Grid::GridState state = (argCount >= 2 ? luapuz_checkGridState(L, 2) : puz::Grid::GRID_ALL);
    bool returns = grid->SetupGrid(state);
    lua_pushboolean(L, returns);
    return 1;
}
// bool IsGridSetup(puz::Grid::GridState state = puz::Grid::GRID_ALL)
static int Grid_IsGridSetup(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    int argCount = lua_gettop(L);
    puz::Grid::GridState state = (argCount >= 2 ? luapuz_checkGridState(L, 2) : puz::Grid::GRID_ALL);
    bool returns = grid->IsGridSetup(state);
    lua_pushboolean(L, returns);
    return 1;
}
// void SetSize(size_t width, size_t height)
static int Grid_SetSize(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    size_t width = luapuz_checkuint(L, 2);
    size_t height = luapuz_checkuint(L, 3);
    grid->SetSize(width, height);
    return 0;
}
// size_t GetWidth()
static int Grid_GetWidth(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    size_t returns = grid->GetWidth();
    lua_pushnumber(L, returns);
    return 1;
}
// size_t GetHeight()
static int Grid_GetHeight(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    size_t returns = grid->GetHeight();
    lua_pushnumber(L, returns);
    return 1;
}
// int LastRow()
static int Grid_LastRow(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    int returns = grid->LastRow();
    lua_pushnumber(L, returns);
    return 1;
}
// int LastCol()
static int Grid_LastCol(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    int returns = grid->LastCol();
    lua_pushnumber(L, returns);
    return 1;
}
// bool IsEmpty()
static int Grid_IsEmpty(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    bool returns = grid->IsEmpty();
    lua_pushboolean(L, returns);
    return 1;
}
// void Clear()
static int Grid_Clear(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    grid->Clear();
    return 0;
}
// Square * First()
static int Grid_First(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    puz::Square * returns = grid->First();
    luapuz_pushSquare(L, returns);
    return 1;
}
// Square * Last()
static int Grid_Last(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    puz::Square * returns = grid->Last();
    luapuz_pushSquare(L, returns);
    return 1;
}
// Square * FirstWhite()
static int Grid_FirstWhite(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    puz::Square * returns = grid->FirstWhite();
    luapuz_pushSquare(L, returns);
    return 1;
}
// Square * LastWhite()
static int Grid_LastWhite(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    puz::Square * returns = grid->LastWhite();
    luapuz_pushSquare(L, returns);
    return 1;
}
// bool IsScrambled()
static int Grid_IsScrambled(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    bool returns = grid->IsScrambled();
    lua_pushboolean(L, returns);
    return 1;
}
// bool HasSolution()
static int Grid_HasSolution(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    bool returns = grid->HasSolution();
    lua_pushboolean(L, returns);
    return 1;
}
// unsigned short GetFlag()
static int Grid_GetFlag(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short returns = grid->GetFlag();
    lua_pushnumber(L, returns);
    return 1;
}
// void SetFlag(unsigned short flag)
static int Grid_SetFlag(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short flag = luapuz_checkuint(L, 2);
    grid->SetFlag(flag);
    return 0;
}
// bool IsDiagramless()
static int Grid_IsDiagramless(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    bool returns = grid->IsDiagramless();
    lua_pushboolean(L, returns);
    return 1;
}
// unsigned short GetType()
static int Grid_GetType(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short returns = grid->GetType();
    lua_pushnumber(L, returns);
    return 1;
}
// void SetType(unsigned short type)
static int Grid_SetType(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short type = luapuz_checkuint(L, 2);
    grid->SetType(type);
    return 0;
}
// bool ScrambleSolution(unsigned short key = 0)
static int Grid_ScrambleSolution(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    int argCount = lua_gettop(L);
    unsigned short key = (argCount >= 2 ? luapuz_checkuint(L, 2) : 0);
    bool returns = grid->ScrambleSolution(key);
    lua_pushboolean(L, returns);
    return 1;
}
// bool UnscrambleSolution(unsigned short key)
static int Grid_UnscrambleSolution(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short key = luapuz_checkuint(L, 2);
    bool returns = grid->UnscrambleSolution(key);
    lua_pushboolean(L, returns);
    return 1;
}
// bool CheckScrambledGrid()
static int Grid_CheckScrambledGrid(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    bool returns = grid->CheckScrambledGrid();
    lua_pushboolean(L, returns);
    return 1;
}
// unsigned short GetKey()
static int Grid_GetKey(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short returns = grid->GetKey();
    lua_pushnumber(L, returns);
    return 1;
}
// void SetKey(unsigned short key)
static int Grid_SetKey(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short key = luapuz_checkuint(L, 2);
    grid->SetKey(key);
    return 0;
}
// unsigned short GetCksum()
static int Grid_GetCksum(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short returns = grid->GetCksum();
    lua_pushnumber(L, returns);
    return 1;
}
// void SetCksum(unsigned short cksum)
static int Grid_SetCksum(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    unsigned short cksum = luapuz_checkuint(L, 2);
    grid->SetCksum(cksum);
    return 0;
}
// bool IsBetween(puz::Square * square, puz::Square * start, puz::Square * end)
static int Grid_IsBetween(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    puz::Square * square = luapuz_checkSquare(L, 2);
    puz::Square * start = luapuz_checkSquare(L, 3);
    puz::Square * end = luapuz_checkSquare(L, 4);
    bool returns = grid->IsBetween(square, start, end);
    lua_pushboolean(L, returns);
    return 1;
}
// bool CheckSquare(puz::Square & square, bool checkBlank = false)
static int Grid_CheckSquare(lua_State * L)
{
    puz::Grid * grid = luapuz_checkGrid(L, 1);
    int argCount = lua_gettop(L);
    puz::Square * square = luapuz_checkSquare(L, 2);
    bool checkBlank = (argCount >= 3 ? luapuz_checkboolean(L, 3) : false);
    bool returns = grid->CheckSquare(*square, checkBlank);
    lua_pushboolean(L, returns);
    return 1;
}
static const luaL_reg Gridlib[] = {
    {"_index", Grid__index},
    {"_newindex", Grid__newindex},
    {"SetupGrid", Grid_SetupGrid},
    {"IsGridSetup", Grid_IsGridSetup},
    {"SetSize", Grid_SetSize},
    {"GetWidth", Grid_GetWidth},
    {"GetHeight", Grid_GetHeight},
    {"LastRow", Grid_LastRow},
    {"LastCol", Grid_LastCol},
    {"IsEmpty", Grid_IsEmpty},
    {"Clear", Grid_Clear},
    {"First", Grid_First},
    {"Last", Grid_Last},
    {"FirstWhite", Grid_FirstWhite},
    {"LastWhite", Grid_LastWhite},
    {"IsScrambled", Grid_IsScrambled},
    {"HasSolution", Grid_HasSolution},
    {"GetFlag", Grid_GetFlag},
    {"SetFlag", Grid_SetFlag},
    {"IsDiagramless", Grid_IsDiagramless},
    {"GetType", Grid_GetType},
    {"SetType", Grid_SetType},
    {"ScrambleSolution", Grid_ScrambleSolution},
    {"UnscrambleSolution", Grid_UnscrambleSolution},
    {"CheckScrambledGrid", Grid_CheckScrambledGrid},
    {"GetKey", Grid_GetKey},
    {"SetKey", Grid_SetKey},
    {"GetCksum", Grid_GetCksum},
    {"SetCksum", Grid_SetCksum},
    {"IsBetween", Grid_IsBetween},
    {"CheckSquare", Grid_CheckSquare},
    {NULL, NULL}
};


// enum GridState
//------------

const char * GridState_meta = "puz.Grid.GridState";

const luapuz_enumReg GridState_reg[] = {
    {"GRID_NONE", puz::Grid::GRID_NONE},
    {"GRID_SIZE", puz::Grid::GRID_SIZE},
    {"GRID_ITERATION", puz::Grid::GRID_ITERATION},
    {"GRID_SOLUTION", puz::Grid::GRID_SOLUTION},
    {"GRID_ALL", puz::Grid::GRID_ALL},
    {NULL, NULL}
};

const luaL_reg staticGridlib[] = {
    {NULL, NULL}
};

const luaL_reg classGridlib[] = {
    { "__gc",        Grid_gc },
    { "__index",     luapuz_index },
    { "__newindex",  luapuz_newindex },
    { "__tostring",  Grid_tostring },
    { NULL, NULL }
};

void luapuz_openGridlib (lua_State *L) {
    luaL_newmetatable(L, Grid_meta);

    // register metatable functions
    luaL_register(L, NULL, Gridlib);
    luaL_register(L, NULL, classGridlib);

    // remove metatable from stack
    lua_pop(L, 1);

    // puz.Grid table
    lua_newtable(L);
    luaL_register(L, NULL, staticGridlib);
    // Register constructor
    luapuz_registerConstructor(L, Grid_Grid);
    luapuz_registerEnum(L, GridState_meta, GridState_reg);
    // puz.Grid = the table
    lua_setfield(L, -2, "Grid");
}
