-- Generate the following files for use with lua-curl.c:
-- curlopt.h
-- curl_netrcopt.h
-- curl_authopt.h
-- curl_ftpauthopt.h
-- curl_ftpmethods.h
-- curl_form.h
-- curl_error.h

if not curlinclude then curlinclude = 'curl/include' end


local ident = '%s*([%a%d_][%a%d_]*)%s*'
local num = '%s*(%d+)%s*'

-- pattern is used as the input to string.find
-- if pattern_func is present, it will be called instead of string.find
-- format is used as the input to string.format
-- if format_func is present, it will be called instead of string.format

-- Each of these patterns operates line-by-line
local line_gen =
{
    ['curlopt.h'] = {
        pattern = '^%s*CINIT%(' .. ident .. ',' .. ident .. ',' .. num .. '%),%s*',
        format  = '{ "OPT_%s", CURLOPTTYPE_%s + %s },'
    },

    ['curl_netrcopt.h'] = {
        pattern = '^%s*CURL_(NETRC_[A-Z]*),',
        format_func = function(opt)
            return '{ "' .. opt .. '", (int) CURL_' .. opt .. ' },'
        end
    },

    ['curl_authopt.h'] = {
        pattern = '#define CURL(AUTH_[A-Z_]+)%s+(%S+).*',
        format = '{ "%s", %s },'
    },

    ['curl_ftpauthopt.h'] = {
        -- Don't return CURLFTPAUTH_LAST
        pattern_func = function(line)
            result = line:match('^%s*CURLFTPAUTH_([A-Z_]+)%s*,')
            if result == 'LAST' then return nil end
            return result
        end,

        format_func = function(opt)
            return '{ "FTPAUTH_' .. opt .. '", CURLFTPAUTH_' .. opt .. ' },'
        end
    },

    ['curl_ftpmethods.h'] = {
        -- Don't return CURLFTPMETHOD_LAST
        pattern_func = function(line)
            result = line:match('^%s*CURLFTPMETHOD_([A-Z_]+)%s*,')
            if result == 'LAST' then return nil end
            return result
        end,

        format_func = function(opt)
            return '{ "FTPMETHOD_' .. opt .. '", CURLFTPMETHOD_' .. opt .. ' },'
        end
    },

    ['curl_form.h'] = {
        pattern = '^%s*CFINIT%(' .. ident .. '%),%s*',
        format_func = function(form)
            return '{ "FORM_' .. form .. '", CURLFORM_' .. form .. ' },'
        end
    },

    ['curl_error.h'] = {
        pattern = '^%s*CURLE_' .. ident,
        format_func = function(e)
            if e:sub(1,8) ~= 'OBSOLETE' then
                return '{ "' .. e .. '", CURLE_' .. e .. ' },'
            end
        end
    },
}


-- Clean up line_gen so that all patterns are turned into pattern_func's and
-- all formats are turned into format_func's
for file, args in pairs(line_gen) do
    -- Adapt pattern_func to return a table
    local pattern_func
    if not args.pattern_func then
        pattern_func = function(line) return line:match(args.pattern) end
    else
        pattern_func = args.pattern_func
    end
    args.pattern_func = function(line)
        return { pattern_func(line) }
    end

    -- Adapt format_func to accept a table and unpack it
    if not args.format_func then
        args.format_func = function(results)
            return args.format:format(unpack(results))
        end
    else
        local old_func = args.format_func
        args.format_func = function(results)
            return old_func(unpack(results))
        end
    end
end


-- Search for the pattern and return the result formatted correctly
function do_search(line, args)
    local results = args.pattern_func(line)
    if #results == 0 then return nil end
    return args.format_func(results)
end


function main()
    -- curl.h is the file that contains all the definitions
    f = io.open('../curl/curl.h', 'rb')
    output = {}
    for file, args in pairs(line_gen) do output[file] = {} end

    for line in f:lines() do
        for file, args in pairs(line_gen) do
            result = do_search(line, args)
            if result then table.insert(output[file], result) end
        end
    end
    f:close()

    for filename, lines in pairs(output) do
        f = io.open(filename, 'w')
        print('writing file:', filename)
        f:write(
[[/* This file generated by curldefs.lua for use by lua-curl */
]])
        for _,line in ipairs(lines) do
            print('    ' .. line)
            f:write(line .. '\n')
        end
        f:close()
    end
end


main()